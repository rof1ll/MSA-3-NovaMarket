## ADR-001: Реализация агрегированной истории заказов
# Статус: активно

---
## Контекст

В рамках развития NovaMarket необходимо реализовать сценарий «Просмотр истории покупок».

Пользователь должен иметь возможность:

- Просматривать список всех своих заказов
    
- Видеть состав заказа, итоговую сумму, способ оплаты и доставки
    
- Получать финальный статус заказа
    
- Скачать чек
    
- Повторить заказ
    
- Оставить отзыв
    

Система построена на микросервисной архитектуре с событийным взаимодействием (EDA) через Kafka.

Данные о заказе распределены между несколькими сервисами:

- Сервис заказов
    
- Платёжный сервис
    
- Сервис логистики
    
- Частично сервис инвентаризации
    

При этом для всех пользовательских интерфейсов действует требование по отклику:

- 98% запросов ≤ 0.3 секунды
    
- 99.99% запросов ≤ 1 секунды
    

История заказов является read-heavy сценарием и потенциально может создавать значительную нагрузку.

---
## Проблема

Если агрегировать данные истории заказов через синхронные вызовы к нескольким микросервисам (API Composition), это приведёт к:

- Увеличению времени отклика
    
- Росту связности сервисов
    
- Повышенному риску каскадных отказов
    
- Сложности масштабирования
    
- Увеличению нагрузки на командную модель
    

Необходимо обеспечить:

- Минимальный latency
    
- Масштабируемость
    
- Изоляцию read-нагрузки
    
- Сохранение событийной архитектуры

---

## Принятое решение

Выбран паттерн:

> CQRS

Будет реализован отдельный микросервис истории заказов, который:

- Подписывается на события в Kafka:
    
    - OrderCreated
        
    - OrderCompleted
        
    - OrderCancelled
        
    - PaymentSucceeded
        
    - DeliveryDelivered
        
- Формирует денормализованную проекцию заказа
    
- Хранит данные в собственной базе данных
    
- Обслуживает исключительно read-запросы
    

Командная модель (создание и изменение заказов) остаётся в Сервисе заказов.

Таким образом:

- Write-side и Read-side разделены
    
- История заказов обслуживается одним быстрым запросом к собственной БД
    
- Сервисы записи не участвуют в обработке read-запросов

---
## Рассмотренные альтернативы

### 1. API Composition

Реализация отдельного агрегирующего сервиса, который при каждом запросе истории выполняет синхронные вызовы:

- Сервис заказов
    
- Платёжный сервис
    
- Сервис логистики
    

**Преимущества:**

- Простая реализация
    
- Нет дублирования данных
    
- Не требуется отдельная база
    

**Недостатки:**

- Высокая латентность
    
- Риск каскадных отказов
    
- Рост связности
    
- Сложность масштабирования
    
- Потенциальное несоответствие SLA
    

Решение признано неприемлемым при масштабировании до 40 000+ заказов в день.

---
## Последствия

### Положительные

- Минимальный latency при чтении
    
- Горизонтальное масштабирование read-side
    
- Изоляция read-нагрузки
    
- Соответствие требованиям SLA
    
- Возможность добавления новых read-моделей без изменения командной логики
    

### Отрицательные

- Eventual consistency
    
- Дублирование данных
    
- Необходимость поддержки механизма проекций
    
- Повышенные требования к идемпотентности обработчиков событий

---
## Влияние на архитектуру

- В систему добавляется новый микросервис истории заказов
    
- Добавляется отдельная база данных для read-модели
    
- Увеличивается роль событий как источника правды для построения проекций
    
- Усиливается разделение командной и запросной модели

---
## Обоснование выбора

С учётом:

- Существующей событийной архитектуры
    
- Использования Kafka
    
- Требований по производительности
    
- Плана масштабирования
    

Выбор CQRS с денормализованной read-моделью является оптимальным компромиссом между сложностью, производительностью и масштабируемостью.